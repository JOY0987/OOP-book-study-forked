# 챕터 9

## 유연한 설계

### 개방 - 폐쇄 원칙
- *확장에 대해 열려 있고, 수정에 대해 닫혀 있어야 한다*
- 변경에 맞는 새로운 동작을 추가하여 기능을 "확장"한다
- 기존의 코드를 "수정"하지 않으면서 동작을 추가, 변경한다
- 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

### 추상화가 핵심이다
- 추상화는 핵심 부분만 남기고 불필요한 부분은 생략한다 <br/> 
이후 문맥에 맞는 내용으로 채워서 구체화, 확장해서 사용한다

### 생성 사용 분리
- 객체 생성을 위해 객체에 대한 지식이 필요하므로 필연적으로 결합도가 높아진다
- 유연하고 재사용 가능한 설계를 위해 객체 생성을 다른 곳에 해야된다
- FACTORY : 생성과 사용 분리를 위해 객체 생성에 특화된 객체 <br/>
FACTORY를 사용함으로써 객체의 책임을 덜어낼 수 있다
- 객체 분해 <br/>
표현적 분해 : 도메인 객체를 활용해 시스템을 분해 <br/>
행위적 분해 : 도메인과 무관한 객체에게 책임을 할당하여 시스템을 분해 <br/>
  - PURE FABRICATION 패턴 

### 의존성 주입
- 객체가 인스턴스를 사용할 책임이 있다  = 누군가 생성된 인스턴스를 전달해야 한다
- 생성자 주입, setter 주입, 메서드 주입 <br/>

❓ 인터페이스 주입만의 강점이 뭘까 <br/>

- SERVICE LOCATOR : 의존성을 해결해줄 객체를 모으는 장소 <br/>
의존성을 감춰서 의존성을 해결한다
  - 그러나 내부 구현을 이해할 필요가 있기 때문에 캡슐화를 위반한다

### 의존성 역전 원칙
- 전통적인 소프트웨어 개발 : 상위 수준 모듈 ➡️ 하위 수준 모듈에 의존
- 구조를 "역전"하여 상위, 하위 수준 모듈 모두 추상화에 의존하게 만든다
- 인터페이스 소유권에도 적용한 원칙 : SEPARATED INTERFACE 패턴 <br/>
추상화를 독립된 패키지가 아닌 클라이언트와 같은 패키지에 포함한다 <br/>

❓ 직관적으로 볼 때, 추상화한 클래스하고 그 자식 클래스가 서로 다른 패키지에 있는 것이 맞을까? <br/>

### 유연성
- 무조건적으로 유연한 설계는 독이 되기도 한다
- 유연한 설계 = 복잡한 설계
