# 객체지향 프로그래밍
## 1. 요구사항 분석
- 설계는 트레이드 오프의 산물
## 2. 협력, 객체, 클래스
 - 클래스를 먼저 결정하고 어떤 속성과 메서드가 필요한지 고민하는 것은 객체지향 본질과 거리가 멀다.
 - 클래스가 아니라 객체에 초점을 맞추자.
### 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라.
- 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 <br> 가지는지를 먼저 결정해야 한다.
- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
### 도메인
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 클래스 이름은 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다.
### 클래스 구현하기
#### 자율적인 객체
 - 객체는 상태와 행동을 함께 가진다.
 - 객체는 스스로 판단하고 행동하는 자율적인 존재이다.
 - ##### 인터페이스와 구현의 분리
   - 퍼블릭 인터페이스 : 외부에서 접근 가능한 부분
   - 구현 : 내부에서만 접근 가능한 부분
#### 프로그래머의 역할
- 클래스 작성자 
  - 새로운 데이터 타입을 프로그램에 추가
  - 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨야 한다. (구현 은닉)
- 클라이언트 프로그래머 
  - 클래스 작성자가 추가한 데이터 타입을 사용
  - 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축
## 3. 협력하는 객체들의 공동체
- 하나의 인스턴스 변수만 포함하더라도 클래스로 설계하여 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음
- 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 협력이라 한다.
  - 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청하고, 요청받은 객체는 요청을 처리한 후 응답한다.
  - 메세지 : 다른 객체와 상호작용할 수 있는 유일한 수단.
  - 메서드 : 수신된 메세지를 처리하기 위한 자신만의 방법
- TEMPLATE METHOD 패턴 : 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴
## 4. 상속과 다형성
### 컴파일 시간 의존성과 실행 시간 의존성
- 컴파일 시간에는 부모 클래스에 의존하지만 실행 시간에 자식 인스턴스에 의존하는 것으로 바뀐다.
- 이 말은 클래스 사이의 의존성(컴파일 타임)과 객체(인스턴스) 사이의 의존성(런타임)은 동일하지 않을 수 있다는 뜻
- 컴파일 타임과 런타임의 의존성이 다르면 다를 수록 코드를 이해하기 어려워지지만, 더 유연해지고 확장 가능해진다.
### 차이에 의한 프로그래밍
- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
- 업 캐스팅 : 자식 클래스가 부모 클래스를 대신하는 것
- 다형성 : 동일한 메세지지만 실행되는 메서드는 객체의 클래스가 무엇이냐에 따라 달라지는 것
#### 바인딩
- 자연 바인딩 (동적 바인딩) : 런타임에 메세지와 메서드를 바인딩하는 것
- 초기 바인딩 (정적 바인딩) : 커파일 타임에 실행될 함수나 프로시저를 결정하는 것
### 상속
- 구현 상속 (서브 클래싱) : 순수하게 코드를 재사용할 목적으로 상속하는 것
- 인터페이스 상속 (서브 타이핑) : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속하는 것
- 구현 상속이 아니라 인터페이스 상속을 위해 상속을 사용해야 한다.
### 인터페이스와 다형성
- 구현은 공유할 필요가 없고 순수하게 인터페이스만 공유하고 싶을 때 인터페이스를 사용한다. C++에서는 추상 기반 클래스를 사용한다.
## 5. 추상화와 유연성
### 추상화의 장점
- 요구사항의 정책을 높은 수준에서 서술할 수 있다.
- 설계가 좀 더 유연해진다.
### 추상 클래스와 인터페이스 트레이드오프
- 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다.
- 모든 코드에는 합당한 이유가 있어야 한다.
### 합성
- 코드 재사용을 목적으로는 상속보다 합성을 사용하자.
- 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용
#### 상속의 단점
- 캡슐화를 위반한다. -> 변경하기도 어려워진다.
- 설계가 유연하지 않다.
- 결론 : 코드를 재사용하는 경우에는 상속보다 합성을 선호, 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 사용