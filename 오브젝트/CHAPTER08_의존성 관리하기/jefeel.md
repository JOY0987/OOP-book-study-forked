# 챕터 8

## 의존성 관리하기

### 의존성
- 협력을 위해 객체가 서로 간에 정보를 알아야 한다 ➡️ 의존성을 낳는다
- 과도한 의존성은 변경에 취약하다

### 변경과 의존성
- 실행 시점 : 정상적인 작동을 위해 실행 시 의존 대상 객체가 함께 존재해야 됨 <br/>
구현 시점 : 의존 대상 객체가 변경되면 의존하는 객체도 함께 변경됨
- 의존성 전이 : PeriodCondion은 Screening 뿐만 아니라 <br/>
Screening이 의존하고 있는 Movie에 대해서도 의존한다.
```mermaid
graph LR
    PeriodConditon --> Screening --> Movie
```

- 런타임 의존성 : 실행 시점 <br/> 
컴파일타임 의존성 : 컴파일이 진행되는 시점 or 코드 그 자체 <br/>
유연한 코드를 설계하기 위해서 서로 다르게 만들어야 한다
- 컨텍스트(문맥) 독립성 : 클래스가 사용될 특정 문맥에 대해 최소한의 가정만으로 이루어 재사용성을 높임
- 의존성 해결 : 컴파일타임 의존성을 컨텍스트에 맞게 런타임 의존성으로 교체함

### 의존성과 결합도
- 바람직한 의존성은 재사용성이 높다
- 특정 컨텍스트에 강하게 결합되면 올바르지 못한 의존성이다
- 두 요소 사이의 결합도가 느슨해야 (=약해야) 올바르다
- 결합도의 정도는 의존하고 있는 요소에 대해 알고 있는 정보의 양으로 결정됨  <br/>
- 더 많이 알수록 강하게 결합된다. 재사용하기 어려워진다 <br/>
➡️ 해결책은 추상화 ❗
```mermaid
---
title : 갈수록 결합도가 느슨해진다
---
graph LR
    구체&nbsp클래스&nbsp의존성 --> 추상&nbsp클래스&nbsp의존성 --> 인터페이스&nbsp의존성
```

### 명시적인 의존성 vs 숨겨진 의존성
- 의존성이 명시적이지 않다면 의존성 파악이 어려워진다
- 의존성 해결 측면에서도 명시적인 의존성은 필요하다

### new는 해롭다?
- 코드에 new를 작성하는 순간 (=구체 클래스를 명시) 구체 클래스에 의존하게 된다
- 구체 클래스를 작성하면서 인자도 적어야 하기 때문에 <br/> 알아야 하는 정보도 늘어난다 (=결합도가 높아진다)

### 유연하고 재사용 가능한 설계
- how to do가 아닌 what to do를 표현하라
- 따라서 의존성 관리는 필수불가결하다